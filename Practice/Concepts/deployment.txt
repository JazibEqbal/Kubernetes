ğŸ§© Deployment (what it is)
Deployment: Controller that manages ReplicaSets and Pods
Ensures desired state (replicas, updates, self-healing)

ğŸ§± Core Objects
ReplicaSet
    Created and managed by Deployment
    Ensures the specified number of Pods are running

Pod Template (spec.template)
    Blueprint used to create Pods
    Same structure as a Pod spec

ğŸ”¢ Scaling & Availability
replicas
    Number of Pods to run
    Can be manually or auto-scaled

HPA (Horizontal Pod Autoscaler)
    Scales Pods based on CPU / memory / custom metrics
    Works with Deployment

ğŸ¯ Labels & Selectors
labels
    Tags applied to Pods

selector
    Defines which Pods the Deployment manages
    Must match Pod template labels

matchLabels / matchExpressions
    Ways to match Pods via selectors

ğŸ”„ Rollouts & Updates

RollingUpdate
    Default update strategy
    Gradually replaces old Pods with new ones
Recreate
    Terminates all Pods before creating new ones
    Causes downtime
maxSurge
    Extra Pods allowed during update
maxUnavailable
    Pods allowed to be unavailable during update

âª Rollback & History

revisionHistoryLimit
    Number of old ReplicaSets kept

Rollback
    Revert to a previous revision

Deployment revision
    Versioned history of changes

ğŸ§ª Health & Lifecycle

livenessProbe
    Restarts container if unhealthy

readinessProbe
    Controls traffic routing to Pods

startupProbe
    Handles slow-starting containers

ğŸ›  Pod Behavior
restartPolicy
    Always (default for Deployments)

resources
    CPU/memory requests & limits

env / envFrom
    Environment variables

volumes / volumeMounts
    Attach storage to Pods

ğŸ§  Status & Management

desiredReplicas
availableReplicas
updatedReplicas
observedGeneration
(Seen in kubectl describe deployment)

Why affinity matters in production
Without affinity:
    All replicas may land on one node âŒ
    Node crash = full outage âŒ

With anti-affinity:
    Pods spread across nodes âœ…
    Node crash = partial impact âœ…

Node affinity filters which nodes a pod can run on, but it cannot enforce distribution across nodes. 
Topology keys are used only with pod affinity, anti-affinity, or topology spread constraints.

Kubernetes QoS (Quality Of Service) Classes:
    BestEffort (lowest priority)
        No requests, No limits. resources: {}
    Burstable âš–ï¸ (balanced â€“ most common)
        Has requests, Limits are higher than requests (or only requests set)
    Guaranteed ğŸ›¡ï¸ (highest priority)
        requests == limits for CPU & memory

Use Deployment when the app is stateless:
    * Donâ€™t care which pod serves traffic
    * Can restart anywhere
    * Donâ€™t need disk identity

If your app needs memory of the past â†’ StatefulSet. If it doesnâ€™t â†’ Deployment.**

Cluster
 â””â”€â”€ Controller (Deployment / StatefulSet / Job)
      â””â”€â”€ Pod
           â””â”€â”€ Container
           
restartPolicy is applicable to Pods.